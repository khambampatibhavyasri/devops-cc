name: Campus Connect CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER }}
  GKE_ZONE: ${{ secrets.GKE_ZONE }}
  GAR_LOCATION: asia-south1
  REPOSITORY: campusconnect-repo
  FRONTEND_IMAGE: campusconnect-frontend
  BACKEND_IMAGE: campusconnect-backend

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: |
          cc/package-lock.json
          server/package-lock.json

    - name: Install Frontend Dependencies
      working-directory: ./cc
      run: |
        npm ci
        npm list react-router-dom || npm install react-router-dom

    - name: Install Backend Dependencies
      working-directory: ./server
      run: npm ci

    - name: Run Frontend Tests
      working-directory: ./cc
      run: |
        npm run test -- --coverage --watchAll=false --passWithNoTests
      continue-on-error: true

    - name: Run Backend Tests
      working-directory: ./server
      run: |
        npm test
      continue-on-error: true

    - name: Lint Frontend Code
      working-directory: ./cc
      run: |
        if npm run lint > /dev/null 2>&1; then
          npm run lint
        else
          echo "Lint script not available, skipping..."
        fi
      continue-on-error: true

  trigger-jenkins:
    name: Trigger Jenkins Build
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Trigger Jenkins Job
      run: |
        # Check if Jenkins secrets are configured
        if [ -z "${{ secrets.JENKINS_URL }}" ] || [ -z "${{ secrets.JENKINS_USER }}" ] || [ -z "${{ secrets.JENKINS_TOKEN }}" ]; then
          echo "‚ùå ERROR: Jenkins secrets not configured!"
          echo "Required secrets: JENKINS_URL, JENKINS_USER, JENKINS_TOKEN"
          echo "Please configure these secrets in your GitHub repository settings."
          exit 1
        fi

        echo "üîç Diagnosing Jenkins connectivity..."
        echo "Jenkins URL: ${{ secrets.JENKINS_URL }}"
        echo "Jenkins User: ${{ secrets.JENKINS_USER }}"

        # Test basic connectivity
        echo "üåê Testing Jenkins connectivity..."
        if curl -s --connect-timeout 10 "${{ secrets.JENKINS_URL }}" > /dev/null; then
          echo "‚úÖ Jenkins server is reachable"
        else
          echo "‚ùå Cannot reach Jenkins server"
          exit 1
        fi

        # Test authentication
        echo "üîê Testing Jenkins authentication..."
        AUTH_TEST=$(curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
          "${{ secrets.JENKINS_URL }}/api/json" -w "%{http_code}" -o /tmp/auth_test.txt)

        if [ "$AUTH_TEST" = "200" ]; then
          echo "‚úÖ Jenkins authentication successful"
        else
          echo "‚ùå Jenkins authentication failed (HTTP $AUTH_TEST)"
          echo "Response:"
          cat /tmp/auth_test.txt || echo "No response body"
          echo ""
          echo "üí° Troubleshooting steps:"
          echo "1. Verify JENKINS_USER is correct"
          echo "2. Verify JENKINS_TOKEN is an API token (not password)"
          echo "3. Check if user has proper permissions"
          echo "4. Ensure Jenkins security realm allows API access"
          exit 1
        fi

        # Check if job exists
        echo "üéØ Checking if job 'campusconnect-pipeline' exists..."
        JOB_CHECK=$(curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
          "${{ secrets.JENKINS_URL }}/job/campusconnect-pipeline/api/json" -w "%{http_code}" -o /tmp/job_check.txt)

        if [ "$JOB_CHECK" = "200" ]; then
          echo "‚úÖ Job 'campusconnect-pipeline' exists"
        else
          echo "‚ùå Job 'campusconnect-pipeline' not found (HTTP $JOB_CHECK)"
          echo "Available jobs:"
          curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
            "${{ secrets.JENKINS_URL }}/api/json" | \
            python3 -c "import sys, json; jobs = json.load(sys.stdin).get('jobs', []); [print(f\"  - {job['name']}\") for job in jobs]" 2>/dev/null || echo "  Could not list jobs"
          exit 1
        fi

        # Get CSRF crumb if needed
        echo "üîê Getting CSRF crumb..."
        CRUMB_RESPONSE=$(curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
          "${{ secrets.JENKINS_URL }}/crumbIssuer/api/json" -w "%{http_code}")
        CRUMB_CODE=$(echo "$CRUMB_RESPONSE" | tail -c 4)

        if [ "$CRUMB_CODE" = "200" ]; then
          CRUMB=$(echo "$CRUMB_RESPONSE" | head -c -4 | python3 -c "import sys, json; print(json.load(sys.stdin)['crumb'])" 2>/dev/null)
          CRUMB_FIELD=$(echo "$CRUMB_RESPONSE" | head -c -4 | python3 -c "import sys, json; print(json.load(sys.stdin)['crumbRequestField'])" 2>/dev/null)
          echo "‚úÖ CSRF protection enabled, crumb obtained"
        else
          echo "‚ö†Ô∏è  No CSRF protection or crumb unavailable"
          CRUMB=""
          CRUMB_FIELD=""
        fi

        # Trigger the build
        echo "üöÄ Triggering Jenkins build..."

        if [ -n "$CRUMB" ] && [ -n "$CRUMB_FIELD" ]; then
          # Use CSRF crumb
          BUILD_RESPONSE=$(curl -X POST \
            -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
            -H "$CRUMB_FIELD: $CRUMB" \
            "${{ secrets.JENKINS_URL }}/job/campusconnect-pipeline/build" \
            --data-urlencode "token=github-trigger" \
            --data-urlencode "cause=GitHub commit by ${{ github.actor }}" \
            -w "%{http_code}" -o /tmp/build_response.txt -s)
        else
          # Direct trigger without CSRF
          BUILD_RESPONSE=$(curl -X POST \
            -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
            "${{ secrets.JENKINS_URL }}/job/campusconnect-pipeline/build" \
            --data-urlencode "token=github-trigger" \
            --data-urlencode "cause=GitHub commit by ${{ github.actor }}" \
            -w "%{http_code}" -o /tmp/build_response.txt -s)
        fi

        # Check build trigger result
        if [ "$BUILD_RESPONSE" = "201" ] || [ "$BUILD_RESPONSE" = "200" ]; then
          echo "‚úÖ Jenkins build triggered successfully! (HTTP $BUILD_RESPONSE)"
        else
          echo "‚ùå Jenkins build trigger failed (HTTP $BUILD_RESPONSE)"
          echo "Response:"
          cat /tmp/build_response.txt || echo "No response body"

          if [ "$BUILD_RESPONSE" = "401" ]; then
            echo ""
            echo "üîß Jenkins 401 Unauthorized Solutions:"
            echo "1. Create API Token: Jenkins ‚Üí User ‚Üí Configure ‚Üí API Token"
            echo "2. Enable remote triggers: Job Config ‚Üí Build Triggers ‚Üí Trigger builds remotely"
            echo "3. Set authentication token: Use 'github-trigger' as token"
            echo "4. Check user permissions: Ensure user can trigger builds"
          elif [ "$BUILD_RESPONSE" = "403" ]; then
            echo ""
            echo "üîß Jenkins 403 Forbidden Solutions:"
            echo "1. Check job permissions: User needs build permission"
            echo "2. Verify CSRF settings match"
            echo "3. Check Jenkins security configuration"
          fi

          exit 1
        fi

  build-and-deploy:
    name: Build and Deploy to GKE
    needs: [test, trigger-jenkins]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        install_components: 'gke-gcloud-auth-plugin'

    - name: Configure Docker for Artifact Registry
      run: gcloud --quiet auth configure-docker $GAR_LOCATION-docker.pkg.dev

    - name: Get GKE credentials
      run: |
        gcloud container clusters get-credentials "$GKE_CLUSTER" --zone "$GKE_ZONE"
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True

    - name: Build Frontend Docker Image
      run: |
        docker build -t "$GAR_LOCATION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$FRONTEND_IMAGE:$GITHUB_SHA" \
          -t "$GAR_LOCATION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$FRONTEND_IMAGE:latest" \
          -f cc/Dockerfile cc/

    - name: Build Backend Docker Image
      run: |
        docker build -t "$GAR_LOCATION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$BACKEND_IMAGE:$GITHUB_SHA" \
          -t "$GAR_LOCATION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$BACKEND_IMAGE:latest" \
          -f server/Dockerfile server/

    - name: Push Images to Artifact Registry
      run: |
        docker push "$GAR_LOCATION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$FRONTEND_IMAGE:$GITHUB_SHA"
        docker push "$GAR_LOCATION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$FRONTEND_IMAGE:latest"
        docker push "$GAR_LOCATION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$BACKEND_IMAGE:$GITHUB_SHA"
        docker push "$GAR_LOCATION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$BACKEND_IMAGE:latest"

    - name: Update Kubernetes Manifests
      run: |
        sed -i "s|asia-south1-docker.pkg.dev/devops-cc-472518/campusconnect-repo/campusconnect-frontend:latest|$GAR_LOCATION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$FRONTEND_IMAGE:$GITHUB_SHA|g" k8s/frontend-deployment.yaml
        sed -i "s|asia-south1-docker.pkg.dev/devops-cc-472518/campusconnect-repo/campusconnect-backend:latest|$GAR_LOCATION-docker.pkg.dev/$PROJECT_ID/$REPOSITORY/$BACKEND_IMAGE:$GITHUB_SHA|g" k8s/backend-deployment.yaml

    - name: Deploy to GKE
      run: |
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/backend-deployment.yaml
        kubectl apply -f k8s/frontend-deployment.yaml

        # Wait for rollout to complete
        kubectl rollout status deployment/backend --timeout=600s
        kubectl rollout status deployment/frontend --timeout=600s
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True

    - name: Get Service URLs
      run: |
        echo "Getting service information..."
        kubectl get services
        echo ""
        echo "Frontend URL: http://$(kubectl get service frontend-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}'):30000"
        echo "Backend URL: http://$(kubectl get service backend-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}'):30001"
      env:
        USE_GKE_GCLOUD_AUTH_PLUGIN: True

  notify:
    name: Notify Deployment Status
    needs: [build-and-deploy]
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Deployment Success Notification
      if: needs.build-and-deploy.result == 'success'
      run: |
        echo "‚úÖ Campus Connect deployed successfully!"
        echo "Commit: ${{ github.sha }}"
        echo "Author: ${{ github.actor }}"

    - name: Deployment Failure Notification
      if: needs.build-and-deploy.result == 'failure'
      run: |
        echo "‚ùå Campus Connect deployment failed!"
        echo "Commit: ${{ github.sha }}"
        echo "Author: ${{ github.actor }}"